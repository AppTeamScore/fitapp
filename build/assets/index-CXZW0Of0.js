import{r as o,z as R,u as M}from"./index-B7RkBDmu.js";function b(n,e,{checkForDefaultPrevented:t=!0}={}){return function(s){if(n?.(s),t===!1||!s.defaultPrevented)return e?.(s)}}var g=globalThis?.document?o.useLayoutEffect:()=>{},S=R[" useId ".trim().toString()]||(()=>{}),y=0;function L(n){const[e,t]=o.useState(S());return g(()=>{t(r=>r??String(y++))},[n]),n||(e?`radix-${e}`:"")}function D(n){const e=o.useRef(n);return o.useEffect(()=>{e.current=n}),o.useMemo(()=>(...t)=>e.current?.(...t),[])}var h=R[" useInsertionEffect ".trim().toString()]||g;function F({prop:n,defaultProp:e,onChange:t=()=>{},caller:r}){const[s,c,m]=O({defaultProp:e,onChange:t}),a=n!==void 0,f=a?n:s;{const u=o.useRef(n!==void 0);o.useEffect(()=>{const l=u.current;l!==a&&console.warn(`${r} is changing from ${l?"controlled":"uncontrolled"} to ${a?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),u.current=a},[a,r])}const i=o.useCallback(u=>{if(a){const l=I(u)?u(n):u;l!==n&&m.current?.(l)}else c(u)},[a,n,c,m]);return[f,i]}function O({defaultProp:n,onChange:e}){const[t,r]=o.useState(n),s=o.useRef(t),c=o.useRef(e);return h(()=>{c.current=e},[e]),o.useEffect(()=>{s.current!==t&&(c.current?.(t),s.current=t)},[t,s]),[t,r,c]}function I(n){return typeof n=="function"}function P(n,e){return o.useReducer((t,r)=>e[t][r]??t,n)}var T=n=>{const{present:e,children:t}=n,r=w(e),s=typeof t=="function"?t({present:r.isPresent}):o.Children.only(t),c=M(r.ref,C(s));return typeof t=="function"||r.isPresent?o.cloneElement(s,{ref:c}):null};T.displayName="Presence";function w(n){const[e,t]=o.useState(),r=o.useRef(null),s=o.useRef(n),c=o.useRef("none"),m=n?"mounted":"unmounted",[a,f]=P(m,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}});return o.useEffect(()=>{const i=v(r.current);c.current=a==="mounted"?i:"none"},[a]),g(()=>{const i=r.current,u=s.current;if(u!==n){const N=c.current,d=v(i);n?f("MOUNT"):d==="none"||i?.display==="none"?f("UNMOUNT"):f(u&&N!==d?"ANIMATION_OUT":"UNMOUNT"),s.current=n}},[n,f]),g(()=>{if(e){let i;const u=e.ownerDocument.defaultView??window,l=d=>{const A=v(r.current).includes(CSS.escape(d.animationName));if(d.target===e&&A&&(f("ANIMATION_END"),!s.current)){const p=e.style.animationFillMode;e.style.animationFillMode="forwards",i=u.setTimeout(()=>{e.style.animationFillMode==="forwards"&&(e.style.animationFillMode=p)})}},N=d=>{d.target===e&&(c.current=v(r.current))};return e.addEventListener("animationstart",N),e.addEventListener("animationcancel",l),e.addEventListener("animationend",l),()=>{u.clearTimeout(i),e.removeEventListener("animationstart",N),e.removeEventListener("animationcancel",l),e.removeEventListener("animationend",l)}}else f("ANIMATION_END")},[e,f]),{isPresent:["mounted","unmountSuspended"].includes(a),ref:o.useCallback(i=>{r.current=i?getComputedStyle(i):null,t(i)},[])}}function v(n){return n?.animationName||"none"}function C(n){let e=Object.getOwnPropertyDescriptor(n.props,"ref")?.get,t=e&&"isReactWarning"in e&&e.isReactWarning;return t?n.ref:(e=Object.getOwnPropertyDescriptor(n,"ref")?.get,t=e&&"isReactWarning"in e&&e.isReactWarning,t?n.props.ref:n.props.ref||n.ref)}export{T as P,D as a,g as b,b as c,L as d,F as u};
